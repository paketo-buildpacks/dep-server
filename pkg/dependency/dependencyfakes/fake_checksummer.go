// Code generated by counterfeiter. DO NOT EDIT.
package dependencyfakes

import (
	"sync"

	"github.com/paketo-buildpacks/dep-server/pkg/dependency"
)

type FakeChecksummer struct {
	GetSHA256Stub        func(string) (string, error)
	getSHA256Mutex       sync.RWMutex
	getSHA256ArgsForCall []struct {
		arg1 string
	}
	getSHA256Returns struct {
		result1 string
		result2 error
	}
	getSHA256ReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	SplitPGPKeysStub        func(string) []string
	splitPGPKeysMutex       sync.RWMutex
	splitPGPKeysArgsForCall []struct {
		arg1 string
	}
	splitPGPKeysReturns struct {
		result1 []string
	}
	splitPGPKeysReturnsOnCall map[int]struct {
		result1 []string
	}
	VerifyASCStub        func(string, string, ...string) error
	verifyASCMutex       sync.RWMutex
	verifyASCArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 []string
	}
	verifyASCReturns struct {
		result1 error
	}
	verifyASCReturnsOnCall map[int]struct {
		result1 error
	}
	VerifyMD5Stub        func(string, string) error
	verifyMD5Mutex       sync.RWMutex
	verifyMD5ArgsForCall []struct {
		arg1 string
		arg2 string
	}
	verifyMD5Returns struct {
		result1 error
	}
	verifyMD5ReturnsOnCall map[int]struct {
		result1 error
	}
	VerifySHA1Stub        func(string, string) error
	verifySHA1Mutex       sync.RWMutex
	verifySHA1ArgsForCall []struct {
		arg1 string
		arg2 string
	}
	verifySHA1Returns struct {
		result1 error
	}
	verifySHA1ReturnsOnCall map[int]struct {
		result1 error
	}
	VerifySHA256Stub        func(string, string) error
	verifySHA256Mutex       sync.RWMutex
	verifySHA256ArgsForCall []struct {
		arg1 string
		arg2 string
	}
	verifySHA256Returns struct {
		result1 error
	}
	verifySHA256ReturnsOnCall map[int]struct {
		result1 error
	}
	VerifySHA512Stub        func(string, string) error
	verifySHA512Mutex       sync.RWMutex
	verifySHA512ArgsForCall []struct {
		arg1 string
		arg2 string
	}
	verifySHA512Returns struct {
		result1 error
	}
	verifySHA512ReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeChecksummer) GetSHA256(arg1 string) (string, error) {
	fake.getSHA256Mutex.Lock()
	ret, specificReturn := fake.getSHA256ReturnsOnCall[len(fake.getSHA256ArgsForCall)]
	fake.getSHA256ArgsForCall = append(fake.getSHA256ArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("GetSHA256", []interface{}{arg1})
	fake.getSHA256Mutex.Unlock()
	if fake.GetSHA256Stub != nil {
		return fake.GetSHA256Stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getSHA256Returns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeChecksummer) GetSHA256CallCount() int {
	fake.getSHA256Mutex.RLock()
	defer fake.getSHA256Mutex.RUnlock()
	return len(fake.getSHA256ArgsForCall)
}

func (fake *FakeChecksummer) GetSHA256Calls(stub func(string) (string, error)) {
	fake.getSHA256Mutex.Lock()
	defer fake.getSHA256Mutex.Unlock()
	fake.GetSHA256Stub = stub
}

func (fake *FakeChecksummer) GetSHA256ArgsForCall(i int) string {
	fake.getSHA256Mutex.RLock()
	defer fake.getSHA256Mutex.RUnlock()
	argsForCall := fake.getSHA256ArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeChecksummer) GetSHA256Returns(result1 string, result2 error) {
	fake.getSHA256Mutex.Lock()
	defer fake.getSHA256Mutex.Unlock()
	fake.GetSHA256Stub = nil
	fake.getSHA256Returns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeChecksummer) GetSHA256ReturnsOnCall(i int, result1 string, result2 error) {
	fake.getSHA256Mutex.Lock()
	defer fake.getSHA256Mutex.Unlock()
	fake.GetSHA256Stub = nil
	if fake.getSHA256ReturnsOnCall == nil {
		fake.getSHA256ReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getSHA256ReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeChecksummer) SplitPGPKeys(arg1 string) []string {
	fake.splitPGPKeysMutex.Lock()
	ret, specificReturn := fake.splitPGPKeysReturnsOnCall[len(fake.splitPGPKeysArgsForCall)]
	fake.splitPGPKeysArgsForCall = append(fake.splitPGPKeysArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("SplitPGPKeys", []interface{}{arg1})
	fake.splitPGPKeysMutex.Unlock()
	if fake.SplitPGPKeysStub != nil {
		return fake.SplitPGPKeysStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.splitPGPKeysReturns
	return fakeReturns.result1
}

func (fake *FakeChecksummer) SplitPGPKeysCallCount() int {
	fake.splitPGPKeysMutex.RLock()
	defer fake.splitPGPKeysMutex.RUnlock()
	return len(fake.splitPGPKeysArgsForCall)
}

func (fake *FakeChecksummer) SplitPGPKeysCalls(stub func(string) []string) {
	fake.splitPGPKeysMutex.Lock()
	defer fake.splitPGPKeysMutex.Unlock()
	fake.SplitPGPKeysStub = stub
}

func (fake *FakeChecksummer) SplitPGPKeysArgsForCall(i int) string {
	fake.splitPGPKeysMutex.RLock()
	defer fake.splitPGPKeysMutex.RUnlock()
	argsForCall := fake.splitPGPKeysArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeChecksummer) SplitPGPKeysReturns(result1 []string) {
	fake.splitPGPKeysMutex.Lock()
	defer fake.splitPGPKeysMutex.Unlock()
	fake.SplitPGPKeysStub = nil
	fake.splitPGPKeysReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeChecksummer) SplitPGPKeysReturnsOnCall(i int, result1 []string) {
	fake.splitPGPKeysMutex.Lock()
	defer fake.splitPGPKeysMutex.Unlock()
	fake.SplitPGPKeysStub = nil
	if fake.splitPGPKeysReturnsOnCall == nil {
		fake.splitPGPKeysReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.splitPGPKeysReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeChecksummer) VerifyASC(arg1 string, arg2 string, arg3 ...string) error {
	fake.verifyASCMutex.Lock()
	ret, specificReturn := fake.verifyASCReturnsOnCall[len(fake.verifyASCArgsForCall)]
	fake.verifyASCArgsForCall = append(fake.verifyASCArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 []string
	}{arg1, arg2, arg3})
	fake.recordInvocation("VerifyASC", []interface{}{arg1, arg2, arg3})
	fake.verifyASCMutex.Unlock()
	if fake.VerifyASCStub != nil {
		return fake.VerifyASCStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.verifyASCReturns
	return fakeReturns.result1
}

func (fake *FakeChecksummer) VerifyASCCallCount() int {
	fake.verifyASCMutex.RLock()
	defer fake.verifyASCMutex.RUnlock()
	return len(fake.verifyASCArgsForCall)
}

func (fake *FakeChecksummer) VerifyASCCalls(stub func(string, string, ...string) error) {
	fake.verifyASCMutex.Lock()
	defer fake.verifyASCMutex.Unlock()
	fake.VerifyASCStub = stub
}

func (fake *FakeChecksummer) VerifyASCArgsForCall(i int) (string, string, []string) {
	fake.verifyASCMutex.RLock()
	defer fake.verifyASCMutex.RUnlock()
	argsForCall := fake.verifyASCArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeChecksummer) VerifyASCReturns(result1 error) {
	fake.verifyASCMutex.Lock()
	defer fake.verifyASCMutex.Unlock()
	fake.VerifyASCStub = nil
	fake.verifyASCReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeChecksummer) VerifyASCReturnsOnCall(i int, result1 error) {
	fake.verifyASCMutex.Lock()
	defer fake.verifyASCMutex.Unlock()
	fake.VerifyASCStub = nil
	if fake.verifyASCReturnsOnCall == nil {
		fake.verifyASCReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.verifyASCReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeChecksummer) VerifyMD5(arg1 string, arg2 string) error {
	fake.verifyMD5Mutex.Lock()
	ret, specificReturn := fake.verifyMD5ReturnsOnCall[len(fake.verifyMD5ArgsForCall)]
	fake.verifyMD5ArgsForCall = append(fake.verifyMD5ArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("VerifyMD5", []interface{}{arg1, arg2})
	fake.verifyMD5Mutex.Unlock()
	if fake.VerifyMD5Stub != nil {
		return fake.VerifyMD5Stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.verifyMD5Returns
	return fakeReturns.result1
}

func (fake *FakeChecksummer) VerifyMD5CallCount() int {
	fake.verifyMD5Mutex.RLock()
	defer fake.verifyMD5Mutex.RUnlock()
	return len(fake.verifyMD5ArgsForCall)
}

func (fake *FakeChecksummer) VerifyMD5Calls(stub func(string, string) error) {
	fake.verifyMD5Mutex.Lock()
	defer fake.verifyMD5Mutex.Unlock()
	fake.VerifyMD5Stub = stub
}

func (fake *FakeChecksummer) VerifyMD5ArgsForCall(i int) (string, string) {
	fake.verifyMD5Mutex.RLock()
	defer fake.verifyMD5Mutex.RUnlock()
	argsForCall := fake.verifyMD5ArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeChecksummer) VerifyMD5Returns(result1 error) {
	fake.verifyMD5Mutex.Lock()
	defer fake.verifyMD5Mutex.Unlock()
	fake.VerifyMD5Stub = nil
	fake.verifyMD5Returns = struct {
		result1 error
	}{result1}
}

func (fake *FakeChecksummer) VerifyMD5ReturnsOnCall(i int, result1 error) {
	fake.verifyMD5Mutex.Lock()
	defer fake.verifyMD5Mutex.Unlock()
	fake.VerifyMD5Stub = nil
	if fake.verifyMD5ReturnsOnCall == nil {
		fake.verifyMD5ReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.verifyMD5ReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeChecksummer) VerifySHA1(arg1 string, arg2 string) error {
	fake.verifySHA1Mutex.Lock()
	ret, specificReturn := fake.verifySHA1ReturnsOnCall[len(fake.verifySHA1ArgsForCall)]
	fake.verifySHA1ArgsForCall = append(fake.verifySHA1ArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("VerifySHA1", []interface{}{arg1, arg2})
	fake.verifySHA1Mutex.Unlock()
	if fake.VerifySHA1Stub != nil {
		return fake.VerifySHA1Stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.verifySHA1Returns
	return fakeReturns.result1
}

func (fake *FakeChecksummer) VerifySHA1CallCount() int {
	fake.verifySHA1Mutex.RLock()
	defer fake.verifySHA1Mutex.RUnlock()
	return len(fake.verifySHA1ArgsForCall)
}

func (fake *FakeChecksummer) VerifySHA1Calls(stub func(string, string) error) {
	fake.verifySHA1Mutex.Lock()
	defer fake.verifySHA1Mutex.Unlock()
	fake.VerifySHA1Stub = stub
}

func (fake *FakeChecksummer) VerifySHA1ArgsForCall(i int) (string, string) {
	fake.verifySHA1Mutex.RLock()
	defer fake.verifySHA1Mutex.RUnlock()
	argsForCall := fake.verifySHA1ArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeChecksummer) VerifySHA1Returns(result1 error) {
	fake.verifySHA1Mutex.Lock()
	defer fake.verifySHA1Mutex.Unlock()
	fake.VerifySHA1Stub = nil
	fake.verifySHA1Returns = struct {
		result1 error
	}{result1}
}

func (fake *FakeChecksummer) VerifySHA1ReturnsOnCall(i int, result1 error) {
	fake.verifySHA1Mutex.Lock()
	defer fake.verifySHA1Mutex.Unlock()
	fake.VerifySHA1Stub = nil
	if fake.verifySHA1ReturnsOnCall == nil {
		fake.verifySHA1ReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.verifySHA1ReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeChecksummer) VerifySHA256(arg1 string, arg2 string) error {
	fake.verifySHA256Mutex.Lock()
	ret, specificReturn := fake.verifySHA256ReturnsOnCall[len(fake.verifySHA256ArgsForCall)]
	fake.verifySHA256ArgsForCall = append(fake.verifySHA256ArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("VerifySHA256", []interface{}{arg1, arg2})
	fake.verifySHA256Mutex.Unlock()
	if fake.VerifySHA256Stub != nil {
		return fake.VerifySHA256Stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.verifySHA256Returns
	return fakeReturns.result1
}

func (fake *FakeChecksummer) VerifySHA256CallCount() int {
	fake.verifySHA256Mutex.RLock()
	defer fake.verifySHA256Mutex.RUnlock()
	return len(fake.verifySHA256ArgsForCall)
}

func (fake *FakeChecksummer) VerifySHA256Calls(stub func(string, string) error) {
	fake.verifySHA256Mutex.Lock()
	defer fake.verifySHA256Mutex.Unlock()
	fake.VerifySHA256Stub = stub
}

func (fake *FakeChecksummer) VerifySHA256ArgsForCall(i int) (string, string) {
	fake.verifySHA256Mutex.RLock()
	defer fake.verifySHA256Mutex.RUnlock()
	argsForCall := fake.verifySHA256ArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeChecksummer) VerifySHA256Returns(result1 error) {
	fake.verifySHA256Mutex.Lock()
	defer fake.verifySHA256Mutex.Unlock()
	fake.VerifySHA256Stub = nil
	fake.verifySHA256Returns = struct {
		result1 error
	}{result1}
}

func (fake *FakeChecksummer) VerifySHA256ReturnsOnCall(i int, result1 error) {
	fake.verifySHA256Mutex.Lock()
	defer fake.verifySHA256Mutex.Unlock()
	fake.VerifySHA256Stub = nil
	if fake.verifySHA256ReturnsOnCall == nil {
		fake.verifySHA256ReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.verifySHA256ReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeChecksummer) VerifySHA512(arg1 string, arg2 string) error {
	fake.verifySHA512Mutex.Lock()
	ret, specificReturn := fake.verifySHA512ReturnsOnCall[len(fake.verifySHA512ArgsForCall)]
	fake.verifySHA512ArgsForCall = append(fake.verifySHA512ArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("VerifySHA512", []interface{}{arg1, arg2})
	fake.verifySHA512Mutex.Unlock()
	if fake.VerifySHA512Stub != nil {
		return fake.VerifySHA512Stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.verifySHA512Returns
	return fakeReturns.result1
}

func (fake *FakeChecksummer) VerifySHA512CallCount() int {
	fake.verifySHA512Mutex.RLock()
	defer fake.verifySHA512Mutex.RUnlock()
	return len(fake.verifySHA512ArgsForCall)
}

func (fake *FakeChecksummer) VerifySHA512Calls(stub func(string, string) error) {
	fake.verifySHA512Mutex.Lock()
	defer fake.verifySHA512Mutex.Unlock()
	fake.VerifySHA512Stub = stub
}

func (fake *FakeChecksummer) VerifySHA512ArgsForCall(i int) (string, string) {
	fake.verifySHA512Mutex.RLock()
	defer fake.verifySHA512Mutex.RUnlock()
	argsForCall := fake.verifySHA512ArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeChecksummer) VerifySHA512Returns(result1 error) {
	fake.verifySHA512Mutex.Lock()
	defer fake.verifySHA512Mutex.Unlock()
	fake.VerifySHA512Stub = nil
	fake.verifySHA512Returns = struct {
		result1 error
	}{result1}
}

func (fake *FakeChecksummer) VerifySHA512ReturnsOnCall(i int, result1 error) {
	fake.verifySHA512Mutex.Lock()
	defer fake.verifySHA512Mutex.Unlock()
	fake.VerifySHA512Stub = nil
	if fake.verifySHA512ReturnsOnCall == nil {
		fake.verifySHA512ReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.verifySHA512ReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeChecksummer) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.getSHA256Mutex.RLock()
	defer fake.getSHA256Mutex.RUnlock()
	fake.splitPGPKeysMutex.RLock()
	defer fake.splitPGPKeysMutex.RUnlock()
	fake.verifyASCMutex.RLock()
	defer fake.verifyASCMutex.RUnlock()
	fake.verifyMD5Mutex.RLock()
	defer fake.verifyMD5Mutex.RUnlock()
	fake.verifySHA1Mutex.RLock()
	defer fake.verifySHA1Mutex.RUnlock()
	fake.verifySHA256Mutex.RLock()
	defer fake.verifySHA256Mutex.RUnlock()
	fake.verifySHA512Mutex.RLock()
	defer fake.verifySHA512Mutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeChecksummer) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ dependency.Checksummer = new(FakeChecksummer)
